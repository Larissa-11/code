function machine = lnls_latt_err_apply_errors(name, machine, errors, increment)
%function machine = apply_errors(name, machine, errors, increment)
%
%  Apply the errors generated by generate_errors to the ring model.
%
%  INPUTS:
%    name     : name of the file to save input parameters
%    machine  : might be a model of the ring or a cell array of models of
%               the ring;
%    errors   : structure of errors to be applied (for more details see
%               generate_errors help;
%    increment: float defining the fraction of the errors which will be
%               additively applied to the machines.
%
%  OUTPUT:
%    machine  : cell array of ring models with errors.
%
%  modified 2015/03/05 by Fernando.
%
% SEE ALSO: apply_errors, correct_cod, correct_coupling, correct_optics,
% correct_tunes

nr_mach = size(errors.errors_x, 1);

save([name,'_apply_errors_input.mat'], 'errors', 'increment');

if ~iscell(machine{1})
    machine = repmat({machine},nr_mach,1);
end

if length(machine) ~= nr_mach
    warning('MATLAB:DifferentSizes',...
        'Incompatibility between errors and machine lengths.\n Using minimum of both.');
    nr_mach = min([length(machine),nr_mach]);
end

dim = get_dim(machine{1});

sext_idx = findcells(machine{1}, 'PolynomB');
fprintf('Applying Errors in %3d Machines...\n\n',nr_mach);
fprintf(['Closed Orbit With Sextupoles OFF [' datestr(now) ']:\n\n']);
fprintf('%3s|       codx[mm]       |       codx[mm]       \n', 'ind');
fprintf('   |   (max)  (std)  (avg)  | (max)  (std)  (avg)  \n');
for i=1:nr_mach
    machine{i}    = apply_errors_one_machine(machine{i}, errors, i, increment);
    the_ring = setcellstruct(machine{i}, 'PolynomB', sext_idx, 0, 1, 3);
    [codx, cody] = calc_cod(the_ring, dim);
    fprintf('%03i| %6.2f %6.2f %6.2f | %6.2f %6.2f %6.2f \n', i, ...
        1e3*max(abs(codx)), 1e3*std(codx), 1e3*mean(codx), ...
        1e3*max(abs(cody)), 1e3*std(cody), 1e3*mean(cody));
end
fprintf('\n');


function the_ring = apply_errors_one_machine(the_ring0, errors, machine, fraction)

the_ring  = the_ring0;

err = fraction * errors.errors_x(machine,:);
idx = find(err ~= 0)';
the_ring  = lnls_set_misalignmentX(err(idx), idx, the_ring);

err = fraction * errors.errors_y(machine,:);
idx = find(err ~= 0)';
the_ring  = lnls_set_misalignmentY(err(idx), idx, the_ring);

err = fraction * errors.errors_roll(machine,:);
idx = find(err ~= 0)';
the_ring  = lnls_set_rotation_ROLL(err(idx), idx, the_ring);

err = fraction * errors.errors_yaw(machine,:);
idx = find(err ~= 0)';
the_ring  = lnls_set_rotation_YAW(err(idx), idx, the_ring);

err = fraction * errors.errors_pitch(machine,:);
idx = find(err ~= 0)';
the_ring  = lnls_set_rotation_PITCH(err(idx), idx, the_ring);

err = fraction * errors.errors_e(machine,:);
idx = find(err ~= 0)';
the_ring  = lnls_set_excitation(err(idx), idx, the_ring);

err = fraction * errors.errors_e_kdip(machine,:);
idx = find(err ~= 0)';
the_ring  = lnls_set_excitation_Kdip(err(idx), idx, the_ring);

